;;; dired-hacks-autoloads.el --- automatically extracted autoloads (do not edit)   -*- lexical-binding: t -*-
;; Generated by the `loaddefs-generate' function.

;; This file is part of GNU Emacs.

;;; Code:



;;; Generated autoloads from dired-avfs.el

(register-definition-prefixes "dired-avfs" '("dired-avfs-"))


;;; Generated autoloads from dired-collapse.el

(autoload 'dired-collapse-mode "dired-collapse" "\
Toggle collapsing of unique nested paths in Dired.

This is a minor mode.  If called interactively, toggle the
`Dired-Collapse mode' mode.  If the prefix argument is positive, enable
the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable the
mode if ARG is nil, omitted, or is a positive number.  Disable the mode
if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate the variable `dired-collapse-mode'.

The mode's hook is called both when the mode is enabled and when it is
disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "dired-collapse" '("dired-collapse" "global-dired-collapse-mode" "turn-on-dired-collapse-mode"))


;;; Generated autoloads from dired-columns.el

(register-definition-prefixes "dired-columns" '("dired-columns-"))


;;; Generated autoloads from dired-filter.el

(defvar dired-filter-map (let ((map (make-sparse-keymap))) (define-key map "n" 'dired-filter-by-name) (define-key map "r" 'dired-filter-by-regexp) (define-key map "." 'dired-filter-by-extension) (define-key map "h" 'dired-filter-by-dot-files) (define-key map "o" 'dired-filter-by-omit) (define-key map "g" 'dired-filter-by-garbage) (define-key map "e" 'dired-filter-by-predicate) (define-key map "f" 'dired-filter-by-file) (define-key map "d" 'dired-filter-by-directory) (define-key map "m" 'dired-filter-by-mode) (define-key map "s" 'dired-filter-by-symlink) (define-key map "x" 'dired-filter-by-executable) (define-key map "ig" 'dired-filter-by-git-ignored) (define-key map "|" 'dired-filter-or) (define-key map "!" 'dired-filter-negate) (define-key map "*" 'dired-filter-decompose) (define-key map (kbd "TAB") 'dired-filter-transpose) (define-key map "p" 'dired-filter-pop) (define-key map "/" 'dired-filter-pop-all) (define-key map "S" 'dired-filter-save-filters) (define-key map "D" 'dired-filter-delete-saved-filters) (define-key map "A" 'dired-filter-add-saved-filters) (define-key map "L" 'dired-filter-load-saved-filters) map) "\
Keymap used for filtering files.")
(defvar dired-filter-mark-map (let ((map (make-sparse-keymap))) (define-key map "n" 'dired-filter-mark-by-name) (define-key map "r" 'dired-filter-mark-by-regexp) (define-key map "." 'dired-filter-mark-by-extension) (define-key map "h" 'dired-filter-mark-by-dot-files) (define-key map "o" 'dired-filter-mark-by-omit) (define-key map "g" 'dired-filter-mark-by-garbage) (define-key map "e" 'dired-filter-mark-by-predicate) (define-key map "f" 'dired-filter-mark-by-file) (define-key map "d" 'dired-filter-mark-by-directory) (define-key map "m" 'dired-filter-mark-by-mode) (define-key map "s" 'dired-filter-mark-by-symlink) (define-key map "x" 'dired-filter-mark-by-executable) (define-key map "ig" 'dired-filter-mark-by-git-ignored) (define-key map "L" 'dired-filter-mark-by-saved-filters) map) "\
Keymap used for marking files.")
(autoload 'dired-filter-define "dired-filter" "\
Create a filter NAME.

Files matched by the predicate are kept in the listing.

For filters where the reverse behaviour makes more sense as
default, you can set the `:remove' argument to `t' to flip the
truth value by default.  Do not flip the value in the predicate
itself!

DOCUMENTATION is the documentation of the created filter.

BODY should contain forms which will be evaluated to test whether
or not a particular file should be displayed or not.  The forms
in BODY will be evaluated with FILE-NAME bound to the file name,
and QUALIFIER bound to the current argument of the filter.
During the evaluation point is at the beginning of line.

:description is a short description of this filter (usually one
or two words).

:reader is a form that is used by `interactive' to read optional
argument.  If not specified or nil, the filter does not accept
argument from user.

:qualifier-description is a form to format qualifier for display.

:remove reverses the default matching strategy of the filter.

(fn NAME DOCUMENTATION (&key DESCRIPTION (QUALIFIER-DESCRIPTION \\='(identity qualifier)) READER REMOVE) &rest BODY)" nil t)
(function-put 'dired-filter-define 'lisp-indent-function 2)
(function-put 'dired-filter-define 'doc-string-elt 2)
 (autoload 'dired-filter-by-dot-files "dired-filter")
 (autoload 'dired-filter-mark-by-dot-files "dired-filter")
 (autoload 'dired-filter-by-name "dired-filter")
 (autoload 'dired-filter-mark-by-name "dired-filter")
 (autoload 'dired-filter-by-regexp "dired-filter")
 (autoload 'dired-filter-mark-by-regexp "dired-filter")
 (autoload 'dired-filter-by-extension "dired-filter")
 (autoload 'dired-filter-mark-by-extension "dired-filter")
 (autoload 'dired-filter-by-omit "dired-filter")
 (autoload 'dired-filter-mark-by-omit "dired-filter")
 (autoload 'dired-filter-by-git-ignored "dired-filter")
 (autoload 'dired-filter-mark-by-git-ignored "dired-filter")
 (autoload 'dired-filter-by-garbage "dired-filter")
 (autoload 'dired-filter-mark-by-garbage "dired-filter")
 (autoload 'dired-filter-by-executable "dired-filter")
 (autoload 'dired-filter-mark-by-executable "dired-filter")
 (autoload 'dired-filter-by-predicate "dired-filter")
 (autoload 'dired-filter-mark-by-predicate "dired-filter")
 (autoload 'dired-filter-by-directory "dired-filter")
 (autoload 'dired-filter-mark-by-directory "dired-filter")
 (autoload 'dired-filter-by-file "dired-filter")
 (autoload 'dired-filter-mark-by-file "dired-filter")
 (autoload 'dired-filter-by-mode "dired-filter")
 (autoload 'dired-filter-mark-by-mode "dired-filter")
 (autoload 'dired-filter-by-symlink "dired-filter")
 (autoload 'dired-filter-mark-by-symlink "dired-filter")
(autoload 'dired-filter-transpose "dired-filter" "\
Transpose the two top filters." t)
(autoload 'dired-filter-or "dired-filter" "\
Or the top two filters." t)
(autoload 'dired-filter-negate "dired-filter" "\
Logically negate the top filter." t)
(autoload 'dired-filter-decompose "dired-filter" "\
Decompose the composite filter on top of the stack.

This means, if the filter is an `or' or `not' filter, pop it and
push all its constituents back on the stack." t)
(autoload 'dired-filter-pop "dired-filter" "\
Remove the top filter in this buffer.

(fn &optional ARG)" t)
(autoload 'dired-filter-pop-all "dired-filter" "\
Remove all the filters in this buffer." t)
(autoload 'dired-filter-save-filters "dired-filter" "\
Save the the FILTERS in this dired buffer under a NAME for later use.

(fn NAME FILTERS)" t)
(autoload 'dired-filter-delete-saved-filters "dired-filter" "\
Delete saved filters with NAME from `dired-filter-saved-filters'.

(fn NAME)" t)
(autoload 'dired-filter-load-saved-filters "dired-filter" "\
Set this buffer's filters to filters with NAME from `dired-filter-saved-filters'.

(fn NAME)" t)
(autoload 'dired-filter-add-saved-filters "dired-filter" "\
Add to this buffer's filters filters with NAME from `dired-filter-saved-filters'.

(fn NAME)" t)
(autoload 'dired-filter-mode "dired-filter" "\
Toggle filtering of files in Dired.

When you toggle the filter mode, the filter stack and all other
state is preserved, except the display is not altered.  This
allows you to quickly toggle the active filter without need of
popping the stack and then re-inserting the filters again.

This is a minor mode.  If called interactively, toggle the `Dired-Filter
mode' mode.  If the prefix argument is positive, enable the mode, and if
it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable the
mode if ARG is nil, omitted, or is a positive number.  Disable the mode
if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate the variable `dired-filter-mode'.

The mode's hook is called both when the mode is enabled and when it is
disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "dired-filter" '("dired-filter"))


;;; Generated autoloads from dired-hacks-utils.el

(register-definition-prefixes "dired-hacks-utils" '("dired-"))


;;; Generated autoloads from dired-images.el

(register-definition-prefixes "dired-images" '("di-"))


;;; Generated autoloads from dired-list.el

(autoload 'dired-list-mpc "dired-list" "\
Search mpd(1) database using QUERY and display results as a `dired' buffer.

(fn QUERY)" t)
(autoload 'dired-list-git-ls-files "dired-list" "\
List all files in DIR managed by git and display results as a `dired' buffer.

(fn DIR)" t)
(autoload 'dired-list-hg-locate "dired-list" "\
List all files in DIR managed by mercurial.

Display results as a `dired' buffer.

(fn DIR)" t)
(autoload 'dired-list-locate "dired-list" "\
Locate(1) all files matching NEEDLE and display results as a `dired' buffer.

(fn NEEDLE)" t)
(autoload 'dired-list-find-file "dired-list" "\
Run find(1) on DIR with find command CMD.

By default, directories matching `grep-find-ignored-directories'
and files matching `grep-find-ignored-files' are ignored.

If called with raw prefix argument \\[universal-argument], no
files will be ignored.

(fn DIR CMD)" t)
(autoload 'dired-list-find-name "dired-list" "\
Search DIR recursively for files matching the globbing pattern PATTERN.

PATTERN is a shell wildcard (not an Emacs regexp) and need not be quoted.

By default, directories matching `grep-find-ignored-directories'
and files matching `grep-find-ignored-files' are ignored.

If called with raw prefix argument \\[universal-argument], no
files will be ignored.

(fn DIR PATTERN)" t)
(register-definition-prefixes "dired-list" '("dired-list"))


;;; Generated autoloads from dired-narrow.el

(autoload 'dired-narrow-regexp "dired-narrow" "\
Narrow a dired buffer to the files matching a regular expression." t)
(autoload 'dired-narrow "dired-narrow" "\
Narrow a dired buffer to the files matching a string.

If the string contains spaces, then each word is matched against
the file name separately.  To succeed, all of them have to match
but the order does not matter.

For example \"foo bar\" matches filename \"bar-and-foo.el\"." t)
(autoload 'dired-narrow-fuzzy "dired-narrow" "\
Narrow a dired buffer to the files matching a fuzzy string.

A fuzzy string is constructed from the filter string by inserting
\".*\" between each letter.  This is then matched as regular
expression against the file name." t)
(register-definition-prefixes "dired-narrow" '("dired-narrow-"))


;;; Generated autoloads from dired-open.el

(autoload 'dired-open-file "dired-open" "\
Try `dired-open-functions' to open the thing under point.

That can be either file or any other line of dired listing.

If no function succeeded, run `dired-find-file' normally.

With \\[universal-argument], run `dired-find-file' normally.

(fn &optional ARG)" t)
(register-definition-prefixes "dired-open" '("dired-open-"))


;;; Generated autoloads from dired-rainbow.el

(register-definition-prefixes "dired-rainbow" '("dired-rainbow-"))


;;; Generated autoloads from dired-ranger.el

(autoload 'dired-ranger-copy "dired-ranger" "\
Place the marked items in the copy ring.

With non-nil prefix argument, add the marked items to the current
selection.  This allows you to gather files from multiple dired
buffers for a single paste.

(fn ARG)" t)
(autoload 'dired-ranger-paste "dired-ranger" "\
Copy the items from copy ring to current directory.

With raw prefix argument \\[universal-argument], do not remove
the selection from the stack so it can be copied again.

With numeric prefix argument, copy the n-th selection from the
copy ring.

(fn ARG)" t)
(autoload 'dired-ranger-move "dired-ranger" "\
Move the items from copy ring to current directory.

This behaves like `dired-ranger-paste' but moves the files
instead of copying them.

(fn ARG)" t)
(autoload 'dired-ranger-bookmark "dired-ranger" "\
Bookmark current dired buffer.

CHAR is a single character (a-zA-Z0-9) representing the bookmark.
Reusing a bookmark replaces the content.  These bookmarks are not
persistent, they are used for quick jumping back and forth
between currently used directories.

(fn CHAR)" t)
(autoload 'dired-ranger-bookmark-visit "dired-ranger" "\
Visit bookmark CHAR.

If the associated dired buffer was killed, we try to reopen it
according to the setting `dired-ranger-bookmark-reopen'.

The special bookmark `dired-ranger-bookmark-LRU' always jumps to
the least recently visited dired buffer.

See also `dired-ranger-bookmark'.

(fn CHAR)" t)
(register-definition-prefixes "dired-ranger" '("dired-ranger-"))


;;; Generated autoloads from dired-subtree.el

(autoload 'dired-subtree-narrow "dired-subtree" "\
Narrow the buffer to this subtree." t)
(autoload 'dired-subtree-up "dired-subtree" "\
Jump up one directory.

(fn &optional ARG)" t)
(autoload 'dired-subtree-down "dired-subtree" "\
Jump down one directory.

(fn &optional ARG)" t)
(autoload 'dired-subtree-next-sibling "dired-subtree" "\
Go to the next sibling.

(fn &optional ARG)" t)
(autoload 'dired-subtree-previous-sibling "dired-subtree" "\
Go to the previous sibling.

(fn &optional ARG)" t)
(autoload 'dired-subtree-beginning "dired-subtree" "\
Go to the first file in this subtree." t)
(autoload 'dired-subtree-end "dired-subtree" "\
Go to the first file in this subtree." t)
(autoload 'dired-subtree-mark-subtree "dired-subtree" "\
Mark all files in this subtree.

With prefix argument mark all the files in subdirectories
recursively.

(fn &optional ALL)" t)
(autoload 'dired-subtree-unmark-subtree "dired-subtree" "\
Unmark all files in this subtree.

With prefix argument unmark all the files in subdirectories
recursively.

(fn &optional ALL)" t)
(autoload 'dired-subtree-revert "dired-subtree" "\
Revert the subtree.

This means reinserting the content of this subtree and all its
children." t)
(autoload 'dired-subtree-insert "dired-subtree" "\
Insert subtree under this directory." t)
(autoload 'dired-subtree-remove "dired-subtree" "\
Remove subtree at point." t)
(autoload 'dired-subtree-toggle "dired-subtree" "\
Insert subtree at point or remove it if it was not present." t)
(autoload 'dired-subtree-cycle "dired-subtree" "\
Org-mode like cycle visibility:

1) Show subtree
2) Show subtree recursively (if previous command was cycle)
3) Remove subtree

Numeric prefix will set max depth

(fn &optional MAX-DEPTH)" t)
(autoload 'dired-subtree-only-this-file "dired-subtree" "\
Remove all the siblings on the route from this file to the top-most directory.

With ARG non-nil, do not remove expanded directories in parents.

(fn &optional ARG)" t)
(autoload 'dired-subtree-only-this-directory "dired-subtree" "\
Remove all the siblings on the route from this directory to the top-most directory.

With ARG non-nil, do not remove expanded directories in parents.

(fn &optional ARG)" t)
(autoload 'dired-subtree-apply-filter "dired-subtree" "\
Push a local filter for this subtree.

This depends on `dired-filter' package.

It works exactly the same as global dired filters, only
restricted to a subtree.  The global filter is also applied to
the subtree.  The filter action is read from `dired-filter-map'." t)
(register-definition-prefixes "dired-subtree" '("dired-"))


;;; Generated autoloads from dired-tagsistant.el

(autoload 'dired-tagsistant-some-tags "dired-tagsistant" "\
Display all files matching some tag in TAGS.

(fn TAGS)" t)
(autoload 'dired-tagsistant-all-tags "dired-tagsistant" "\
Display all files matching all tags in TAGS.

(fn TAGS)" t)
(autoload 'dired-tagsistant-some-tags-regexp "dired-tagsistant" "\
Display all files where some of their tags matches REGEXP.

(fn REGEXP)" t)
(autoload 'dired-tagsistant-all-tags-regexp "dired-tagsistant" "\
Display all files where all of their tags match REGEXP.

(fn REGEXP)" t)
(autoload 'dired-tagsistant-list-tags "dired-tagsistant" "\
Print all tags on each file of FILES.

If FILES contains only one file, print in minibuffer, otherwise
pop a window with a list of all tags for each file.

(fn FILES)" t)
(autoload 'dired-tagsistant-tag "dired-tagsistant" "\
Tag FILES with TAGS by copying them into tagsistant store.

FILES is a list of files to tag.

TAGS is a list of tags to assign to the files.  Each tripple tag
should be represented by one string.  Non-existing tags will be
created automatically.

(fn FILES TAGS)" t)
(autoload 'dired-tagsistant-tag-symlink "dired-tagsistant" "\
Tag files with TAGS by tagging symlinks pointing to them.

Symbolic links are resolved recursively and always point to the
*real* file.  This saves space in the database and make updating
of broken links much simpler.

FILES is a list of files to tag.

TAGS is a list of tags to assign to the files.  Each tripple tag
should be represented by one string.  Non-existing tags will be
created automatically.

(fn FILES TAGS)" t)
(autoload 'dired-tagsistant-add-relation "dired-tagsistant" "\


(fn PARENT REL CHILD)" t)
(register-definition-prefixes "dired-tagsistant" '("dired-tagsistant-"))

;;; End of scraped data

(provide 'dired-hacks-autoloads)

;; Local Variables:
;; version-control: never
;; no-byte-compile: t
;; no-update-autoloads: t
;; no-native-compile: t
;; coding: utf-8-emacs-unix
;; End:

;;; dired-hacks-autoloads.el ends here
